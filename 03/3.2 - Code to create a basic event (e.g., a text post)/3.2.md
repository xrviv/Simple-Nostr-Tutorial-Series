To create a simple event in Nostr, we will add to our existing code. The event will be defined with necessary attributes like kind, created_at, tags, and content. Here's how you can modify and extend the code to include the creation of a simple event:

```
const { generateSecretKey, getPublicKey, nip19, finalizeEvent } = require('nostr-tools');

// Generate a private key
let sk = generateSecretKey();
console.log("Raw Private Key:", Buffer.from(sk).toString('hex'))

// Encode the private key using NIP-19 nsecEncode method
let nsec = nip19.nsecEncode(sk);
console.log("NIP-19 Encoded Private Key (nsec):", nsec);

// Derive the raw public key from the private key
let rawPublicKey = getPublicKey(sk);
console.log("Raw Public Key:", rawPublicKey);

// Encode the public key using NIP-19 npubEncode method
let npub = nip19.npubEncode(rawPublicKey);
console.log("NIP-19 Encoded Public Key (npub):", npub);

// Define an event template
let eventTemplate = {
  kind: 1, // The kind of event, e.g., 1 for a text note
  created_at: Math.floor(Date.now() / 1000), // Timestamp of event creation
  tags: [], // Tags for the event, if any
  content: 'This is a sample Nostr event.', // Content of the event
};

// Sign the event with the private key
let signedEvent = finalizeEvent(eventTemplate, sk);
console.log("Signed Event:", signedEvent);

```
**Run:** After opening index.js, run `node index.js`

**Note:** Don't forget to run `npm install nostr-tools` inside the *nostr-app* folder

### Observations

In the code: 

```
// Define an event template
let eventTemplate = {
  kind: 1, // The kind of event, e.g., 1 for a text note
  created_at: Math.floor(Date.now() / 1000), // Timestamp of event creation
  tags: [], // Tags for the event, if any
  content: 'This is a sample Nostr event.', // Content of the event
};

// Sign the event with the private key
let signedEvent = finalizeEvent(eventTemplate, sk);
console.log("Signed Event:", signedEvent);

```

We notice that the event is signed with 'sk', which is the raw private key we generated and not the NIP-19 encoded one (prefaced with nsec). 

![image](https://github.com/xrviv/Simple-Nostr-Tutorial-Series/assets/44260360/9362af70-3128-4bed-960d-0bb55d824efc)

Successfully runnning `node index.js` We notice that the signed event included `eventTemplate` plus the following fields: `id` and `sig`.

the event is signed using the raw private key (`sk`) and not the NIP-19 encoded private key (`nsec`). This is a crucial aspect of the Nostr protocol and its implementation in `nostr-tools`. Let's clarify why the raw private key is used:

1.  **Raw Private Key (`sk`)**: This is the fundamental cryptographic key used for signing events. In cryptographic operations like signing, the actual key material (i.e., the raw private key) is needed. This key is a Uint8Array representing a sequence of bytes.
2.  **NIP-19 Encoded Private Key (`nsec`)**: This is a representation of the private key encoded according to the NIP-19 standard. The purpose of this encoding is for safer storage and transmission. It's not used directly in cryptographic operations like signing because these operations require the raw binary format of the key.
3.  **Signing Process**: When you sign an event using `finalizeEvent`, it requires the raw private key because this function performs cryptographic operations. The `finalizeEvent` function computes the event's ID, embeds the public key, and signs the event using the provided raw private key.

So, in your code:

-   `generateSecretKey()` generates the raw private key (`sk`).
-   `nip19.nsecEncode(sk)` encodes this key into a NIP-19 format (`nsec`) for secure storage or sharing.
-   `finalizeEvent(eventTemplate, sk)` signs the event using the raw private key (`sk`), not the NIP-19 encoded key (`nsec`).

The NIP-19 encoded keys (`nsec`, `npub`) are typically used for key management purposes, such as storing keys in a more secure format or sharing them with reduced risk of exposure, rather than for direct cryptographic operations like signing events.

### So where did `id` and `sig` come from?

The additional fields `id` and `sig` that appear in the output of your event after calling `finalizeEvent` are automatically generated by the `finalizeEvent` function as part of the event signing process in Nostr. Let's break down what these fields represent:

1.  **`id` Field**: This is the unique identifier for the event. In Nostr, the `id` of an event is a hash derived from its content and other attributes. This identifier is crucial for uniquely identifying the event across the network. When you call `finalizeEvent`, it computes this `id` based on the event's data, including its type, timestamp, tags, content, and the public key of the user who created it.
2.  **`sig` Field**: This is the digital signature of the event. When you sign an event using your private key, the `finalizeEvent` function generates this signature (`sig`). This signature is a cryptographic proof that the event was indeed created by the holder of the private key corresponding to the public key embedded in the event. It's used by others on the network to verify the authenticity and integrity of the event.

**Note:** Over time, the functions in `nostr-tools` can change. This can sometimes break tutorials such as these. But at the time of this writing (2024-01-18), you can find the function finalizeEvent [here.](https://www.npmjs.com/package/nostr-tools?activeTab=code). Simply do a Ctrl + F 'finalizeEvent', where you will see the **finalizeEvent** function: 

```
finalizeEvent(t, secretKey) {
      const event = t;
      event.pubkey = bytesToHex2(schnorr.getPublicKey(secretKey));
      event.id = getEventHash(event);
      event.sig = bytesToHex2(schnorr.sign(getEventHash(event), secretKey));
      event[verifiedSymbol] = true;
      return event;
    }
```